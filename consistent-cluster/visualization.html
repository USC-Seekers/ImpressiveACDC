<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
    <style type="text/css">
        .nodes {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        .links {
            stroke: #999;
            stroke-opacity: .6;
        }

        text {
            stroke-width: 0;
        }

    </style>

</head>
<body>
<div class="ui-widget">
    <label for="search"></label><input id="search">
    <button id="search-button">Search</button>
</div>
<svg id="svg" width="1200" height="800"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script type='text/javascript' src="http://bost.ocks.org/mike/fisheye/fisheye.js?0.0.3"></script>
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

<script>
    var container = null;
    var svg = null;
    var nodes = null;
    var nodesAutoComplete = [];
    var links = null;
    var connected = null;
    var nodeDict = null;
    var d3Nodes = null;
    var d3Links = null;
    var d3Texts = null;
    var connectedToggle = 0;
    var width = 1200;
    var height = 800;
    var colors = ['#FD7F28', '#AFC8E7', '#9ADE8D', '#9369BB', '#FD9898'];

    $(function () {
        $("#search").autocomplete({source: nodesAutoComplete});
        $("#search-button").click(function () {
            if (svg === null) return;
            var searchId = $("#search").val();

            d3Nodes.style("opacity", function(node) {
                return node.id !== searchId && !neighboring(nodeDict[searchId], node) ? 0.1 : 1;
            });
            d3Links.style("opacity", function (link) {
                return link.source !== searchId && link.target !== searchId ? 0.1 : 1;
            });
            d3Texts.style("display", function (node) {
                return node.id !== searchId ? "none" : "";
            });
        });
    });

    var getNodeSize = function (node) {
        return node.level * 20;
    };
    var getNodeColor = function (node) {
        switch (node.type) {
            case "sql":
                return colors[0];
            case "graphics":
                return colors[1];
            case "io":
                return colors[2];
            case "networking":
                return colors[3];
            case "no_match":
                return colors[4];
        }
    };
    var getNodePositionX = function (node) {
        var rv = node.x * 30 + width / 2;
        if (rv < 30) return 30;
        if (rv > width - 30) return width - 30;
        return rv;
    };
    var getNodePositionY = function (node) {
        var rv = node.y * 30 + height / 2;
        if (rv < 30) return 30;
        if (rv > height - 30) return height - 30;
        return rv;
    };

    var moveNode = function (adjNode, node) {
        var r = Math.max(width, height);
        var l = 0;
        var dis = Math.sqrt(adjNode.x * adjNode.x + adjNode.y * adjNode.y);
        var unitX = adjNode.x / dis;
        var unitY = adjNode.y / dis;
        var radiusSumSqr = (adjNode.radius + node.radius) * (adjNode.radius + node.radius);
        var curDis = (node.dx - adjNode.dx) * (node.dx - adjNode.dx) + (node.dy - adjNode.dy) * (node.dy - adjNode.dy);
        if (curDis > radiusSumSqr + 100) return false;
        while (true) {
            var m = (l + r) / 2;
            var ndx = adjNode.dx + m * unitX;
            var ndy = adjNode.dy + m * unitY;
            var diffX = ndx - node.dx;
            var diffY = ndy - node.dy;
            var nDisSqr = diffX * diffX + diffY * diffY;
            if (nDisSqr > radiusSumSqr + 100 && nDisSqr < radiusSumSqr + 225) break;
            else if (nDisSqr < radiusSumSqr + 100) {
                l = m;
            }
            else {
                r = m;
            }
        }
        adjNode.dx += m * unitX;
        adjNode.dy += m * unitY;
        return true;
    };

    var neighboring = function (a, b) {
        return (connected[a.id] && connected[a.id][b.id]) || (connected[b.id] && connected[b.id][a.id]);
    };

    var connectedNodes = function () {
        if (connectedToggle === 0) {
            var node = d3.select(this).node().__data__;
            d3Nodes.style("opacity", function (o) {
                return neighboring(node, o) || node === o ? 1 : 0.1;
            });
            d3Texts.style("display", function (o) {
                return neighboring(node, o) || node === o ? "" : "none";
            });
            d3Links.style("opacity", function (o) {
                return o.source === node.id || o.target === node.id ? 1 : 0.1;
            });
            connectedToggle = 1;
        }
        else {
            d3Nodes.style("opacity", 1);
            d3Links.style("opacity", 1);
            d3Texts.style("display", "none");
            connectedToggle = 0;
        }
    };
    var dragging = function (d) {
        var curX = d.dx + d3.event.x;
        var curY = d.dy + d3.event.y;
        d3.select(this).attr("cx", curX).attr("cy", curY);
        d3Links.filter(function (link) {
            return link.source === d.id;
        })
            .attr("x1", curX)
            .attr("y1", curY);
        d3Links.filter(function (link) {
            return link.target === d.id
        })
            .attr("x2", curX)
            .attr("y2", curY);
        d3Texts.filter(function (o) {
            return o.id === d.id
        })
            .attr("x", curX)
            .attr("y", curY);
    };
    var dragEnd = function (d) {
        d.dx = d.dx + d3.event.x;
        d.dy = d.dy + d3.event.y;
    };
    var zooming = function () {
        container.attr("transform", d3.event.transform);
    };

    var jsonFile = window.location.pathname.split('/').pop();
    d3.json("/ImpressiveACDC/input/" + jsonFile, function (error, graph) {
        nodeDict = {};
        var nodes = graph.nodes.map(function (node) {
            node.dx = getNodePositionX(node);
            node.dy = getNodePositionY(node);
            node.radius = getNodeSize(node);
            node.color = getNodeColor(node);
            nodeDict[node.id] = node;
            nodesAutoComplete.push(node.id);
            return node;
        });
        connected = {};
        links = graph.links;
        graph.links.forEach(function (val) {
            if (!connected[val.source]) {
                connected[val.source] = {}
            }
            connected[val.source][val.target] = true;
        });
        nodes.sort(function (a, b) {
            return (a.x * a.x + a.y * a.y) - (b.x * b.x + b.y * b.y);
        });

        width = window.innerWidth;
        height = window.innerHeight;
        var change = false;
        do {
            change = false;
            for (var i = 0; i < nodes.length; i++) {
                for (var j = i + 1; j < nodes.length; j++) {
                    change = change || moveNode(nodes[i], nodes[j]);
                }
            }
        } while (change === true);

        svg = d3.select("svg");
        svg.attr('width', width).attr('height', height);

        container = svg.append("g").attr("class", "everything");

        d3Links = container
            .append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr('x1', function (link) {
                return nodeDict[link.source].dx;
            })
            .attr('y1', function (link) {
                return nodeDict[link.source].dy;
            })
            .attr('x2', function (link) {
                return nodeDict[link.target].dx;
            })
            .attr('y2', function (link) {
                return nodeDict[link.target].dy;
            })
            .attr("stroke-width", 1)
            .attr("stroke", "rgba(50, 50, 50, 0.2)")
            .style("marker-end", "url(#suit)");

        d3Nodes = container
            .append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", function (d) {
                return d.radius;
            })
            .attr("fill", function (d) {
                return d.color;
            })
            .attr("cx", function (d) {
                return d.dx
            })
            .attr("cy", function (d) {
                return d.dy
            })
            .call(d3.drag().on("drag", dragging).on("end", dragEnd))
            .on('click', connectedNodes);

        d3Texts = container
            .append("g")
            .attr("class", "texts")
            .selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .text(function (node) {
                return node.label;
            })
            .style("display", "none")
            .attr("font-size", 7)
            .attr("dx", 15)
            .attr("dy", 4)
            .attr("x", function (d) {
                return d.dx
            })
            .attr("y", function (d) {
                return d.dy
            });

        d3.zoom().on("zoom", zooming)(svg);
    });
</script>

</body>
</html>